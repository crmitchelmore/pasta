name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0, v2.1.3, etc.

permissions:
  contents: write  # Required to create releases

env:
  APP_NAME: PastaApp
  BUNDLE_ID: com.pasta.clipboard
  DMG_NAME: Pasta

jobs:
  build-and-release:
    name: Build, Sign, Notarize & Release
    runs-on: macos-14  # macOS Sonoma required for Swift 5.9+ and macOS 14 target
    
    steps:
      # ============================================================================
      # CHECKOUT & SETUP
      # ============================================================================
      
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper version detection
      
      - name: Extract version from tag
        id: version
        run: |
          # Extract version from tag (e.g., v1.2.3 -> 1.2.3)
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
      
      # ============================================================================
      # BUILD
      # ============================================================================
      
      - name: Resolve Swift dependencies
        run: swift package resolve
      
      - name: Build release binary (arm64)
        run: swift build -c release --arch arm64
      
      - name: Build release binary (x86_64)
        run: swift build -c release --arch x86_64
      
      - name: Create universal binary
        run: |
          mkdir -p .build/universal
          lipo -create \
            .build/arm64-apple-macosx/release/PastaApp \
            .build/x86_64-apple-macosx/release/PastaApp \
            -output .build/universal/PastaApp
          
          echo "==> Stripping debug symbols"
          strip -x .build/universal/PastaApp
          
          echo "==> Created universal binary"
          file .build/universal/PastaApp
          ls -lh .build/universal/PastaApp
      
      - name: Create app bundle structure
        run: |
          BUILD_DIR=".build/universal"
          # App bundle is named "Pasta.app" but executable inside is still "PastaApp"
          APP_DIR="${BUILD_DIR}/${DMG_NAME}.app"
          
          echo "==> Creating app bundle at $APP_DIR"
          rm -rf "$APP_DIR"
          mkdir -p "$APP_DIR/Contents/MacOS"
          mkdir -p "$APP_DIR/Contents/Resources"
          mkdir -p "$APP_DIR/Contents/Frameworks"
          
          # Copy the universal binary (keep internal name as PastaApp)
          cp ".build/universal/${APP_NAME}" "$APP_DIR/Contents/MacOS/${APP_NAME}"
          
          # Copy resources
          if [ -d "Sources/PastaApp/Resources" ]; then
            cp -R Sources/PastaApp/Resources/* "$APP_DIR/Contents/Resources/" || true
          fi
          
          # Copy app icon to Resources
          cp "Resources/DMG/AppIcon.icns" "$APP_DIR/Contents/Resources/AppIcon.icns"
          
          # Copy Sparkle framework
          SPARKLE_PATH=$(find .build -name "Sparkle.framework" -type d | head -1)
          if [ -n "$SPARKLE_PATH" ]; then
            echo "==> Copying Sparkle framework from $SPARKLE_PATH"
            cp -R "$SPARKLE_PATH" "$APP_DIR/Contents/Frameworks/"
          else
            echo "ERROR: Sparkle.framework not found!"
            exit 1
          fi
          
          # Copy resource bundles (KeyboardShortcuts has localized strings)
          # Only copy unique bundles (avoid duplicates from arm64/x86_64 builds)
          echo "==> Copying resource bundles"
          for bundle in $(find .build -name "*.bundle" -type d); do
            bundle_name=$(basename "$bundle")
            # Skip if already copied (check if destination exists)
            if [ -d "$APP_DIR/Contents/Resources/$bundle_name" ]; then
              echo "Skipping (already exists): $bundle_name"
              continue
            fi
            echo "Copying bundle: $bundle_name"
            cp -R "$bundle" "$APP_DIR/Contents/Resources/"
          done
          
          # Fix rpath to find frameworks in Contents/Frameworks
          echo "==> Fixing rpath for Sparkle framework"
          install_name_tool -add_rpath "@executable_path/../Frameworks" "$APP_DIR/Contents/MacOS/${APP_NAME}"
          
          # Verify rpath
          echo "==> Verifying rpath:"
          otool -l "$APP_DIR/Contents/MacOS/${APP_NAME}" | grep -A2 LC_RPATH
          
          # Make executable
          chmod +x "$APP_DIR/Contents/MacOS/${APP_NAME}"
          
          echo "APP_DIR=$APP_DIR" >> $GITHUB_ENV
      
      - name: Generate Info.plist with version
        env:
          SPARKLE_PUBLIC_KEY: ${{ secrets.SPARKLE_PUBLIC_KEY }}
        run: |
          # Get the short commit SHA
          COMMIT_SHA=$(git rev-parse --short HEAD)
          
          cat > "${APP_DIR}/Contents/Info.plist" <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleName</key>
              <string>Pasta</string>
              <key>CFBundleDisplayName</key>
              <string>Pasta</string>
              <key>CFBundleIdentifier</key>
              <string>${BUNDLE_ID}</string>
              <key>CFBundleVersion</key>
              <string>${GITHUB_RUN_NUMBER}</string>
              <key>CFBundleShortVersionString</key>
              <string>${GITHUB_REF_NAME#v}</string>
              <key>CFBundleExecutable</key>
              <string>${APP_NAME}</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleInfoDictionaryVersion</key>
              <string>6.0</string>
              <key>LSApplicationCategoryType</key>
              <string>public.app-category.productivity</string>
              <key>LSMinimumSystemVersion</key>
              <string>14.0</string>
              <key>NSHighResolutionCapable</key>
              <true/>
              <key>NSPrincipalClass</key>
              <string>NSApplication</string>
              <key>NSHumanReadableCopyright</key>
              <string>Â© $(date +%Y) Pasta</string>
              <key>CFBundleIconFile</key>
              <string>AppIcon</string>
              <key>CFBundleIconName</key>
              <string>AppIcon</string>
              <key>LSUIElement</key>
              <true/>
              <!-- Git Commit SHA for About screen -->
              <key>GitCommitSHA</key>
              <string>${COMMIT_SHA}</string>
              <!-- Sparkle Auto-Update Configuration -->
              <key>SUFeedURL</key>
              <string>https://github.com/crmitchelmore/pasta/releases/latest/download/appcast.xml</string>
              <key>SUPublicEDKey</key>
              <string>${SPARKLE_PUBLIC_KEY}</string>
              <key>SUEnableAutomaticChecks</key>
              <true/>
              <key>SUScheduledCheckInterval</key>
              <integer>86400</integer>
          </dict>
          </plist>
          PLIST
          
          echo "==> Info.plist created"
          cat "${APP_DIR}/Contents/Info.plist"
      
      # ============================================================================
      # CODE SIGNING
      # ============================================================================
      
      - name: Import Developer ID certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_DEVELOPER_ID_APPLICATION }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_DEVELOPER_ID_APPLICATION_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          echo "==> Creating temporary keychain"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          echo "==> Importing certificate"
          echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign
          
          # Set keychain search list
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Clean up certificate file
          rm certificate.p12
          
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          echo "==> Certificate imported successfully"
      
      - name: Find signing identity
        id: signing
        run: |
          # Find the Developer ID Application certificate
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | grep -o '".*"' | tr -d '"')
          
          if [ -z "$IDENTITY" ]; then
            echo "ERROR: No Developer ID Application certificate found!"
            security find-identity -v -p codesigning "$KEYCHAIN_PATH"
            exit 1
          fi
          
          echo "identity=$IDENTITY" >> $GITHUB_OUTPUT
          echo "==> Found signing identity: $IDENTITY"
      
      - name: Create entitlements file
        run: |
          cat > entitlements.plist <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.automation.apple-events</key>
              <true/>
              <key>com.apple.security.cs.disable-library-validation</key>
              <true/>
          </dict>
          </plist>
          PLIST
          
          echo "==> Entitlements file created"
          cat entitlements.plist
      
      - name: Code sign app bundle
        run: |
          echo "==> Signing app bundle with hardened runtime"
          
          # Sign all nested binaries and frameworks first
          find "${APP_DIR}/Contents" -type f -perm +111 | while read binary; do
            if file "$binary" | grep -q "Mach-O"; then
              echo "Signing: $binary"
              codesign --force \
                --sign "${{ steps.signing.outputs.identity }}" \
                --options runtime \
                --timestamp \
                --entitlements entitlements.plist \
                "$binary" || true
            fi
          done
          
          # Sign the app bundle
          codesign --deep --force \
            --sign "${{ steps.signing.outputs.identity }}" \
            --options runtime \
            --timestamp \
            --entitlements entitlements.plist \
            "${APP_DIR}"
          
          echo "==> Verifying signature"
          codesign --verify --verbose=4 "${APP_DIR}"
      
      # ============================================================================
      # CREATE DMG
      # ============================================================================
      
      - name: Install create-dmg and pngquant
        run: brew install create-dmg pngquant
      
      - name: Generate DMG assets
        run: |
          cd Resources/DMG
          
          echo "==> Generating app icon (icns)"
          chmod +x create-icns.sh
          ./create-icns.sh
          
          echo "==> Generating background image"
          chmod +x create-background.sh
          ./create-background.sh
      
      - name: Optimize icon PNGs for smaller DMG
        run: |
          # Optimize the icns by re-creating with compressed PNGs
          ICONSET_DIR=$(mktemp -d)/AppIcon.iconset
          mkdir -p "$ICONSET_DIR"
          
          # Extract iconset
          iconutil -c iconset Resources/DMG/AppIcon.icns -o "$ICONSET_DIR"
          
          # Compress each PNG with pngquant
          echo "==> Compressing icon PNGs..."
          for png in "$ICONSET_DIR"/*.png; do
            pngquant --force --quality=70-90 --output "$png" "$png" || true
          done
          
          # Recreate icns
          iconutil -c icns "$ICONSET_DIR" -o Resources/DMG/AppIcon.icns
          
          echo "==> Optimized icon size:"
          ls -lh Resources/DMG/AppIcon.icns
      
      - name: Create fancy DMG
        id: dmg
        run: |
          DMG_FILE="${DMG_NAME}-${{ steps.version.outputs.version }}.dmg"
          
          echo "==> Creating DMG with custom background and layout"
          create-dmg \
            --volname "${DMG_NAME}" \
            --volicon "Resources/DMG/AppIcon.icns" \
            --background "Resources/DMG/background@2x.png" \
            --window-pos 200 120 \
            --window-size 660 400 \
            --icon-size 100 \
            --icon "${DMG_NAME}.app" 180 200 \
            --app-drop-link 480 200 \
            --hide-extension "${DMG_NAME}.app" \
            --no-internet-enable \
            "${DMG_FILE}" \
            "${APP_DIR}"
          
          echo "dmg_file=$DMG_FILE" >> $GITHUB_OUTPUT
          echo "==> DMG created: $DMG_FILE"
          ls -lh "$DMG_FILE"
      
      # ============================================================================
      # NOTARIZATION
      # ============================================================================
      
      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          DMG_FILE="${{ steps.dmg.outputs.dmg_file }}"
          
          echo "==> Submitting DMG for notarization"
          xcrun notarytool submit "$DMG_FILE" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 60m
          
          echo "==> Notarization successful"
      
      - name: Staple notarization ticket
        run: |
          DMG_FILE="${{ steps.dmg.outputs.dmg_file }}"
          
          echo "==> Stapling notarization ticket to DMG"
          xcrun stapler staple "$DMG_FILE"
          
          echo "==> Verifying stapled ticket"
          xcrun stapler validate "$DMG_FILE"
      
      # ============================================================================
      # VERIFICATION
      # ============================================================================
      
      - name: Verify signed and notarized DMG
        run: |
          DMG_FILE="${{ steps.dmg.outputs.dmg_file }}"
          
          echo "==> Verifying DMG"
          
          # Mount DMG
          hdiutil attach "$DMG_FILE" -mountpoint /tmp/pasta-verify
          
          # Verify signature
          echo "==> Checking code signature"
          codesign --verify --deep --strict --verbose=2 "/tmp/pasta-verify/${DMG_NAME}.app"
          
          # Check notarization ticket (stapler validate on the DMG already verified this)
          echo "==> Checking notarization"
          xcrun stapler validate "$DMG_FILE"
          
          # Unmount
          hdiutil detach /tmp/pasta-verify
          
          echo "==> âœ… All verifications passed!"
      
      # ============================================================================
      # RELEASE
      # ============================================================================
      
      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          cat > release_notes.md <<EOF
          # Pasta ${VERSION}
          
          ## ðŸ Your clipboard, al dente.
          
          A blazing-fast, local-first clipboard history manager for macOS with intelligent content detection.
          
          ### Installation
          
          1. Download \`${{ steps.dmg.outputs.dmg_file }}\`
          2. Open the DMG and drag **Pasta** to your Applications folder
          3. Launch Pasta from Applications
          4. Grant Accessibility permissions when prompted (recommended for full functionality)
          
          ### Requirements
          
          - macOS 14.0 (Sonoma) or later
          - Apple Silicon (M1/M2/M3) or Intel Mac
          
          ### Features
          
          - âœ¨ **Unlimited clipboard history** â€” Never lose a copied item
          - ðŸ§  **Smart content detection** â€” Auto-categorizes emails, JWTs, code, URLs, and more
          - âš¡ **Ultra-fast search** â€” Full-text search with fuzzy matching
          - âŒ¨ï¸  **Keyboard-first** â€” Global hotkey (\`âŒƒâŒ˜C\`) and full navigation
          - ðŸ‘ï¸  **Rich previews** â€” Images, decoded base64, syntax-highlighted code
          - ðŸ”’ **Privacy-first** â€” 100% local storage, no cloud sync
          
          ### Usage
          
          1. Copy anything (text, URLs, images, etc.)
          2. Press **\`âŒƒâŒ˜C\`** to show Pasta
          3. Search, navigate with **â†‘/â†“**, press **Enter** to paste
          
          ### Verification
          
          This release is code-signed and notarized by Apple for secure distribution outside the Mac App Store.
          
          \`\`\`bash
          # Verify code signature
          codesign --verify --deep --strict /Applications/Pasta.app
          
          # Check notarization
          spctl --assess --type execute --verbose /Applications/Pasta.app
          \`\`\`
          
          ### Changelog
          
          See commit history for detailed changes.
          
          ---
          
          **SHA-256 Checksum:**
          \`\`\`
          $(shasum -a 256 "${{ steps.dmg.outputs.dmg_file }}" | awk '{print $1}')
          \`\`\`
          EOF
          
          echo "Release notes generated"
          cat release_notes.md
      
      - name: Generate Appcast for Sparkle Updates
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          BUILD_NUMBER="${GITHUB_RUN_NUMBER}"
          DMG_PATH="${{ steps.dmg.outputs.dmg_file }}"
          
          chmod +x scripts/generate-appcast.sh
          ./scripts/generate-appcast.sh "$VERSION" "$BUILD_NUMBER" "$DMG_PATH" "$SPARKLE_PRIVATE_KEY" > "$RUNNER_TEMP/appcast.xml"
          
          echo "APPCAST_PATH=$RUNNER_TEMP/appcast.xml" >> "$GITHUB_ENV"
          echo "Generated appcast.xml:"
          cat "$RUNNER_TEMP/appcast.xml"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: Pasta ${{ steps.version.outputs.version }}
          body_path: release_notes.md
          files: |
            ${{ steps.dmg.outputs.dmg_file }}
            ${{ env.APPCAST_PATH }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================================================
      # CLEANUP
      # ============================================================================
      
      - name: Cleanup keychain
        if: always()
        run: |
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "==> Cleaning up keychain"
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
      
      - name: Upload build artifacts (for debugging)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: failed-build-artifacts
          path: |
            .build/
            entitlements.plist
            release_notes.md
          retention-days: 7
